// node_modules/dnd-multi-backend/dist/index.js
var D = (r, n, e) => {
  if (!n.has(r))
    throw TypeError("Cannot " + e);
};
var t = (r, n, e) => (D(r, n, "read from private field"), e ? e.call(r) : n.get(r));
var o = (r, n, e) => {
  if (n.has(r))
    throw TypeError("Cannot add the same private member more than once");
  n instanceof WeakSet ? n.add(r) : n.set(r, e);
};
var p = (r, n, e, i) => (D(r, n, "write to private field"), i ? i.call(r, e) : n.set(r, e), e);
var w;
var M = class {
  constructor() {
    o(this, w, void 0);
    this.register = (n) => {
      t(this, w).push(n);
    };
    this.unregister = (n) => {
      let e;
      for (; (e = t(this, w).indexOf(n)) !== -1; )
        t(this, w).splice(e, 1);
    };
    this.backendChanged = (n) => {
      for (let e of t(this, w))
        e.backendChanged(n);
    };
    p(this, w, []);
  }
};
w = /* @__PURE__ */ new WeakMap();
var a;
var l;
var c;
var d;
var h;
var x;
var T;
var E;
var y;
var B;
var f;
var v = class {
  constructor(n, e, i) {
    o(this, a, void 0);
    o(this, l, void 0);
    o(this, c, void 0);
    o(this, d, void 0);
    o(this, h, void 0);
    o(this, x, (n2, e2, i2) => {
      if (!i2.backend)
        throw new Error(`You must specify a 'backend' property in your Backend entry: ${JSON.stringify(i2)}`);
      let u = i2.backend(n2, e2, i2.options), s = i2.id, k = !i2.id && u && u.constructor;
      if (k && (s = u.constructor.name), s)
        k && console.warn(`Deprecation notice: You are using a pipeline which doesn't include backends' 'id'.
        This might be unsupported in the future, please specify 'id' explicitely for every backend.`);
      else
        throw new Error(`You must specify an 'id' property in your Backend entry: ${JSON.stringify(i2)}
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-5xx`);
      if (t(this, c)[s])
        throw new Error(`You must specify a unique 'id' property in your Backend entry:
        ${JSON.stringify(i2)} (conflicts with: ${JSON.stringify(t(this, c)[s])})`);
      return { id: s, instance: u, preview: i2.preview ?? false, transition: i2.transition, skipDispatchOnTransition: i2.skipDispatchOnTransition ?? false };
    });
    this.setup = () => {
      if (!(typeof window > "u")) {
        if (v.isSetUp)
          throw new Error("Cannot have two MultiBackends at the same time.");
        v.isSetUp = true, t(this, T).call(this, window), t(this, c)[t(this, a)].instance.setup();
      }
    };
    this.teardown = () => {
      typeof window > "u" || (v.isSetUp = false, t(this, E).call(this, window), t(this, c)[t(this, a)].instance.teardown());
    };
    this.connectDragSource = (n2, e2, i2) => t(this, f).call(this, "connectDragSource", n2, e2, i2);
    this.connectDragPreview = (n2, e2, i2) => t(this, f).call(this, "connectDragPreview", n2, e2, i2);
    this.connectDropTarget = (n2, e2, i2) => t(this, f).call(this, "connectDropTarget", n2, e2, i2);
    this.profile = () => t(this, c)[t(this, a)].instance.profile();
    this.previewEnabled = () => t(this, c)[t(this, a)].preview;
    this.previewsList = () => t(this, l);
    this.backendsList = () => t(this, d);
    o(this, T, (n2) => {
      t(this, d).forEach((e2) => {
        e2.transition && n2.addEventListener(e2.transition.event, t(this, y));
      });
    });
    o(this, E, (n2) => {
      t(this, d).forEach((e2) => {
        e2.transition && n2.removeEventListener(e2.transition.event, t(this, y));
      });
    });
    o(this, y, (n2) => {
      var _a;
      let e2 = t(this, a);
      if (t(this, d).some((i2) => i2.id !== t(this, a) && i2.transition && i2.transition.check(n2) ? (p(this, a, i2.id), true) : false), t(this, a) !== e2) {
        t(this, c)[e2].instance.teardown(), Object.keys(t(this, h)).forEach((k) => {
          let b = t(this, h)[k];
          b.unsubscribe(), b.unsubscribe = t(this, B).call(this, b.func, ...b.args);
        }), t(this, l).backendChanged(this);
        let i2 = t(this, c)[t(this, a)];
        if (i2.instance.setup(), i2.skipDispatchOnTransition)
          return;
        let u = n2.constructor, s = new u(n2.type, n2);
        (_a = n2.target) == null ? void 0 : _a.dispatchEvent(s);
      }
    });
    o(this, B, (n2, e2, i2, u) => t(this, c)[t(this, a)].instance[n2](e2, i2, u));
    o(this, f, (n2, e2, i2, u) => {
      let s = `${n2}_${e2}`, k = t(this, B).call(this, n2, e2, i2, u);
      return t(this, h)[s] = { func: n2, args: [e2, i2, u], unsubscribe: k }, () => {
        t(this, h)[s].unsubscribe(), delete t(this, h)[s];
      };
    });
    if (!i || !i.backends || i.backends.length < 1)
      throw new Error(`You must specify at least one Backend, if you are coming from 2.x.x (or don't understand this error)
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-2xx`);
    p(this, l, new M()), p(this, c, {}), p(this, d, []), i.backends.forEach((u) => {
      let s = t(this, x).call(this, n, e, u);
      t(this, c)[s.id] = s, t(this, d).push(s);
    }), p(this, a, t(this, d)[0].id), p(this, h, {});
  }
};
var m = v;
a = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), h = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), m.isSetUp = false;
var P = (r, n, e) => new m(r, n, e);
var g = (r, n) => ({ event: r, check: n });
var S = g("touchstart", (r) => {
  let n = r;
  return n.touches !== null && n.touches !== void 0;
});
var L = g("dragstart", (r) => r.type.indexOf("drag") !== -1 || r.type.indexOf("drop") !== -1);
var O = g("mousedown", (r) => r.type.indexOf("touch") === -1 && r.type.indexOf("mouse") !== -1);
var C = g("pointerdown", (r) => r.pointerType == "mouse");

export {
  P,
  g,
  S,
  L,
  O,
  C
};
//# sourceMappingURL=chunk-NVZ5KZUO.js.map
