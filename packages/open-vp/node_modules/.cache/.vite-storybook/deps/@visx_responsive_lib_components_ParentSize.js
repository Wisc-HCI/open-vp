import {
  require_debounce
} from "./chunk-BAUCRRI4.js";
import {
  require_prop_types
} from "./chunk-V6FYUS4A.js";
import "./chunk-WE6C7BYT.js";
import "./chunk-6WWIQWKA.js";
import "./chunk-GEDK2DVG.js";
import "./chunk-HMJV5AKD.js";
import {
  require_react
} from "./chunk-LWCIAKPC.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-TFWDKVI3.js";

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers;
var init_resizeObservers = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"() {
    resizeObservers = [];
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations;
var init_hasActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js"() {
    init_resizeObservers();
    hasActiveObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.activeTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations;
var init_hasSkippedObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js"() {
    init_resizeObservers();
    hasSkippedObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.skippedTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg, deliverResizeLoopError;
var init_deliverResizeLoopError = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js"() {
    msg = "ResizeObserver loop completed with undelivered notifications.";
    deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
var init_ResizeObserverBoxOptions = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js"() {
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
  }
});

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze;
var init_freeze = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/freeze.js"() {
    freeze = function(obj) {
      return Object.freeze(obj);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize;
var init_ResizeObserverSize = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js"() {
    init_freeze();
    ResizeObserverSize = function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly;
var init_DOMRectReadOnly = __esm({
  "node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js"() {
    init_freeze();
    DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG, isHidden, isElement, isReplacedElement;
var init_element = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/element.js"() {
    isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    isHidden = function(target) {
      if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
      }
      var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    isElement = function(obj) {
      var _a;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global;
var init_global = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/global.js"() {
    global = typeof window !== "undefined" ? window : {};
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache, scrollRegexp, verticalRegexp, IE, parseDimension, size, zeroBoxes, calculateBoxSizes, calculateBoxSize;
var init_calculateBoxSize = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js"() {
    init_ResizeObserverBoxOptions();
    init_ResizeObserverSize();
    init_DOMRectReadOnly();
    init_element();
    init_freeze();
    init_global();
    cache = /* @__PURE__ */ new WeakMap();
    scrollRegexp = /auto|scroll/;
    verticalRegexp = /^tb|vertical/;
    IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
    parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry;
var init_ResizeObserverEntry = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js"() {
    init_calculateBoxSize();
    init_freeze();
    ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode;
var init_calculateDepthForNode = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js"() {
    init_element();
    calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations;
var init_broadcastActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js"() {
    init_resizeObservers();
    init_ResizeObserverEntry();
    init_calculateDepthForNode();
    init_calculateBoxSize();
    broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
      });
      for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
      }
      return shallowestDepth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth;
var init_gatherActiveObservationsAtDepth = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js"() {
    init_resizeObservers();
    init_calculateDepthForNode();
    gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro.activeTargets.push(ot);
            } else {
              ro.skippedTargets.push(ot);
            }
          }
        });
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process;
var init_process = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/process.js"() {
    init_hasActiveObservations();
    init_hasSkippedObservations();
    init_deliverResizeLoopError();
    init_broadcastActiveObservations();
    init_gatherActiveObservationsAtDepth();
    process = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger, callbacks, notify, queueMicroTask;
var init_queueMicroTask = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js"() {
    callbacks = [];
    notify = function() {
      return callbacks.splice(0).forEach(function(cb) {
        return cb();
      });
    };
    queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver;
var init_queueResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js"() {
    init_queueMicroTask();
    queueResizeObserver = function(cb) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb);
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching, isWatching, CATCH_PERIOD, observerConfig, events, time, scheduled, Scheduler, scheduler, updateCount;
var init_scheduler = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/scheduler.js"() {
    init_process();
    init_global();
    init_queueResizeObserver();
    watching = 0;
    isWatching = function() {
      return !!watching;
    };
    CATCH_PERIOD = 250;
    observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    scheduled = false;
    Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    scheduler = new Scheduler();
    updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement, ResizeObservation;
var init_ResizeObservation = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObservation.js"() {
    init_ResizeObserverBoxOptions();
    init_calculateBoxSize();
    init_element();
    skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail;
var init_ResizeObserverDetail = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js"() {
    ResizeObserverDetail = function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap, getObservationIndex, ResizeObserverController;
var init_ResizeObserverController = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverController.js"() {
    init_scheduler();
    init_ResizeObservation();
    init_ResizeObserverDetail();
    init_resizeObservers();
    observerMap = /* @__PURE__ */ new WeakMap();
    getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver;
var init_ResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserver.js"() {
    init_ResizeObserverController();
    init_element();
    ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/exports/resize-observer.js
var resize_observer_exports = {};
__export(resize_observer_exports, {
  ResizeObserver: () => ResizeObserver,
  ResizeObserverEntry: () => ResizeObserverEntry,
  ResizeObserverSize: () => ResizeObserverSize
});
var init_resize_observer = __esm({
  "node_modules/@juggle/resize-observer/lib/exports/resize-observer.js"() {
    init_ResizeObserver();
    init_ResizeObserverEntry();
    init_ResizeObserverSize();
  }
});

// node_modules/@visx/responsive/lib/components/ParentSize.js
var require_ParentSize = __commonJS({
  "node_modules/@visx/responsive/lib/components/ParentSize.js"(exports) {
    exports.__esModule = true;
    exports.default = ParentSize;
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _debounce = _interopRequireDefault(require_debounce());
    var _react = _interopRequireWildcard(require_react());
    var _resizeObserver = (init_resize_observer(), __toCommonJS(resize_observer_exports));
    var _excluded = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var defaultIgnoreDimensions = [];
    function ParentSize(_ref) {
      var className = _ref.className, children = _ref.children, _ref$debounceTime = _ref.debounceTime, debounceTime = _ref$debounceTime === void 0 ? 300 : _ref$debounceTime, _ref$ignoreDimensions = _ref.ignoreDimensions, ignoreDimensions = _ref$ignoreDimensions === void 0 ? defaultIgnoreDimensions : _ref$ignoreDimensions, _ref$parentSizeStyles = _ref.parentSizeStyles, parentSizeStyles = _ref$parentSizeStyles === void 0 ? {
        width: "100%",
        height: "100%"
      } : _ref$parentSizeStyles, _ref$enableDebounceLe = _ref.enableDebounceLeadingCall, enableDebounceLeadingCall = _ref$enableDebounceLe === void 0 ? true : _ref$enableDebounceLe, restProps = _objectWithoutPropertiesLoose(_ref, _excluded);
      var target = (0, _react.useRef)(null);
      var animationFrameID = (0, _react.useRef)(0);
      var _useState = (0, _react.useState)({
        width: 0,
        height: 0,
        top: 0,
        left: 0
      }), state = _useState[0], setState = _useState[1];
      var resize = (0, _react.useMemo)(function() {
        var normalized = Array.isArray(ignoreDimensions) ? ignoreDimensions : [ignoreDimensions];
        return (0, _debounce.default)(function(incoming) {
          setState(function(existing) {
            var stateKeys = Object.keys(existing);
            var keysWithChanges = stateKeys.filter(function(key) {
              return existing[key] !== incoming[key];
            });
            var shouldBail = keysWithChanges.every(function(key) {
              return normalized.includes(key);
            });
            return shouldBail ? existing : incoming;
          });
        }, debounceTime, {
          leading: enableDebounceLeadingCall
        });
      }, [debounceTime, enableDebounceLeadingCall, ignoreDimensions]);
      (0, _react.useEffect)(function() {
        var observer = new _resizeObserver.ResizeObserver(function(entries) {
          if (entries === void 0) {
            entries = [];
          }
          entries.forEach(function(entry) {
            var _entry$contentRect = entry.contentRect, left = _entry$contentRect.left, top = _entry$contentRect.top, width = _entry$contentRect.width, height = _entry$contentRect.height;
            animationFrameID.current = window.requestAnimationFrame(function() {
              resize({
                width,
                height,
                top,
                left
              });
            });
          });
        });
        if (target.current)
          observer.observe(target.current);
        return function() {
          window.cancelAnimationFrame(animationFrameID.current);
          observer.disconnect();
          if (resize != null && resize.cancel)
            resize.cancel();
        };
      }, [resize]);
      return _react.default.createElement("div", _extends({
        style: parentSizeStyles,
        ref: target,
        className
      }, restProps), children(_extends({}, state, {
        ref: target.current,
        resize
      })));
    }
    ParentSize.propTypes = {
      className: _propTypes.default.string,
      debounceTime: _propTypes.default.number,
      enableDebounceLeadingCall: _propTypes.default.bool,
      ignoreDimensions: _propTypes.default.oneOfType([_propTypes.default.any, _propTypes.default.arrayOf(_propTypes.default.any)]),
      children: _propTypes.default.func.isRequired
    };
  }
});
export default require_ParentSize();
//# sourceMappingURL=@visx_responsive_lib_components_ParentSize.js.map
