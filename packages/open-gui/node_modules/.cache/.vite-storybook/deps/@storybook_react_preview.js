import {
  require_isPlainObject
} from "./chunk-N5MXRZ73.js";
import {
  require_isString
} from "./chunk-G6GLZUW2.js";
import {
  require_html_tags
} from "./chunk-OPK2AKZH.js";
import {
  ancestor,
  base,
  simple
} from "./chunk-A4HUNBZ2.js";
import {
  require_acorn_jsx
} from "./chunk-LJI2EQ3H.js";
import {
  render,
  renderToCanvas
} from "./chunk-LI4M2HUF.js";
import {
  Parser,
  init_acorn
} from "./chunk-FPK5FQGD.js";
import {
  require_escodegen
} from "./chunk-SYYRYFDA.js";
import "./chunk-7TBZONMI.js";
import {
  require_prop_types
} from "./chunk-V6FYUS4A.js";
import {
  require_dist
} from "./chunk-DWIRGVEP.js";
import {
  SNIPPET_RENDERED,
  SourceType,
  TypeSystem,
  createSummaryValue,
  enhanceArgTypes,
  extractComponentDescription,
  extractComponentProps,
  getDocgenSection,
  hasDocgen,
  isTooLongForDefaultValueSummary,
  isTooLongForTypeSummary
} from "./chunk-5KF3DX2V.js";
import {
  dedent
} from "./chunk-J6CEENEN.js";
import "./chunk-YV5L7AWH.js";
import "./chunk-RT6AJAUP.js";
import "./chunk-KOP5MZZB.js";
import "./chunk-LW5KLQXA.js";
import "./chunk-WJARNYDW.js";
import "./chunk-HWKLNZLO.js";
import "./chunk-DQOWYGZQ.js";
import "./chunk-EUC774OE.js";
import "./chunk-X2VSFWRZ.js";
import "./chunk-IRDHY47F.js";
import "./chunk-H4AD7O6T.js";
import "./chunk-MUYJ6LWT.js";
import "./chunk-5YAOOWTD.js";
import "./chunk-IHYLPFN2.js";
import "./chunk-2MZN2ZPL.js";
import "./chunk-OY4544IE.js";
import {
  require_isFunction
} from "./chunk-43JFV5JL.js";
import "./chunk-VRPUYJUM.js";
import "./chunk-WE6C7BYT.js";
import "./chunk-6CCXOZKY.js";
import "./chunk-6WWIQWKA.js";
import "./chunk-FW7CQS2F.js";
import "./chunk-GEDK2DVG.js";
import "./chunk-HMJV5AKD.js";
import "./chunk-V55I5SVR.js";
import "./chunk-WYLNEF7E.js";
import "./chunk-3GBVF7AK.js";
import "./chunk-UBRMPVXJ.js";
import {
  require_client_logger
} from "./chunk-D77VNDYA.js";
import "./chunk-XOWOABI5.js";
import {
  require_preview_api
} from "./chunk-5H5OTQLV.js";
import "./chunk-6ZDUWZXD.js";
import {
  require_react
} from "./chunk-LWCIAKPC.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/react-element-to-jsx-string/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-element-to-jsx-string/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo2 = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer2(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider2(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef3(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy2(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo3(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler2(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode2(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense2(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef2;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo2;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer2;
        exports.isContextProvider = isContextProvider2;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef3;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy2;
        exports.isMemo = isMemo3;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler2;
        exports.isStrictMode = isStrictMode2;
        exports.isSuspense = isSuspense2;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-element-to-jsx-string/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-element-to-jsx-string/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@storybook/react/dist/config.mjs
var import_prop_types = __toESM(require_prop_types(), 1);
var import_html_tags = __toESM(require_html_tags(), 1);
var import_escodegen = __toESM(require_escodegen(), 1);
init_acorn();
var import_acorn_jsx = __toESM(require_acorn_jsx(), 1);
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var import_isFunction = __toESM(require_isFunction(), 1);
var import_isString = __toESM(require_isString(), 1);

// node_modules/react-element-to-jsx-string/node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/react-element-to-jsx-string/dist/esm/index.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var import_pretty_print_object = __toESM(require_dist());
var import_react_is = __toESM(require_react_is());
var spacer = function(times, tabStop) {
  if (times === 0) {
    return "";
  }
  return new Array(times * tabStop).fill(" ").join("");
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function safeSortObject(value, seen) {
  if (value === null || _typeof(value) !== "object") {
    return value;
  }
  if (value instanceof Date || value instanceof RegExp || React.isValidElement(value)) {
    return value;
  }
  seen.add(value);
  if (Array.isArray(value)) {
    return value.map(function(v) {
      return safeSortObject(v, seen);
    });
  }
  return Object.keys(value).sort().reduce(function(result, key) {
    if (key === "_owner") {
      return result;
    }
    if (key === "current" || seen.has(value[key])) {
      result[key] = "[Circular]";
    } else {
      result[key] = safeSortObject(value[key], seen);
    }
    return result;
  }, {});
}
function sortObject(value) {
  return safeSortObject(value, /* @__PURE__ */ new WeakSet());
}
var createStringTreeNode = function createStringTreeNode2(value) {
  return {
    type: "string",
    value
  };
};
var createNumberTreeNode = function createNumberTreeNode2(value) {
  return {
    type: "number",
    value
  };
};
var createReactElementTreeNode = function createReactElementTreeNode2(displayName, props, defaultProps, childrens) {
  return {
    type: "ReactElement",
    displayName,
    props,
    defaultProps,
    childrens
  };
};
var createReactFragmentTreeNode = function createReactFragmentTreeNode2(key, childrens) {
  return {
    type: "ReactFragment",
    key,
    childrens
  };
};
var supportFragment = Boolean(import_react.Fragment);
var getFunctionTypeName = function getFunctionTypeName2(functionType) {
  if (!functionType.name || functionType.name === "_default") {
    return "No Display Name";
  }
  return functionType.name;
};
var getWrappedComponentDisplayName = function getWrappedComponentDisplayName2(Component) {
  switch (true) {
    case Boolean(Component.displayName):
      return Component.displayName;
    case Component.$$typeof === import_react_is.Memo:
      return getWrappedComponentDisplayName2(Component.type);
    case Component.$$typeof === import_react_is.ForwardRef:
      return getWrappedComponentDisplayName2(Component.render);
    default:
      return getFunctionTypeName(Component);
  }
};
var getReactElementDisplayName = function getReactElementDisplayName2(element) {
  switch (true) {
    case typeof element.type === "string":
      return element.type;
    case typeof element.type === "function":
      if (element.type.displayName) {
        return element.type.displayName;
      }
      return getFunctionTypeName(element.type);
    case (0, import_react_is.isForwardRef)(element):
    case (0, import_react_is.isMemo)(element):
      return getWrappedComponentDisplayName(element.type);
    case (0, import_react_is.isContextConsumer)(element):
      return "".concat(element.type._context.displayName || "Context", ".Consumer");
    case (0, import_react_is.isContextProvider)(element):
      return "".concat(element.type._context.displayName || "Context", ".Provider");
    case (0, import_react_is.isLazy)(element):
      return "Lazy";
    case (0, import_react_is.isProfiler)(element):
      return "Profiler";
    case (0, import_react_is.isStrictMode)(element):
      return "StrictMode";
    case (0, import_react_is.isSuspense)(element):
      return "Suspense";
    default:
      return "UnknownElementType";
  }
};
var noChildren = function noChildren2(propsValue, propName) {
  return propName !== "children";
};
var onlyMeaningfulChildren = function onlyMeaningfulChildren2(children) {
  return children !== true && children !== false && children !== null && children !== "";
};
var filterProps = function filterProps2(originalProps, cb) {
  var filteredProps = {};
  Object.keys(originalProps).filter(function(key) {
    return cb(originalProps[key], key);
  }).forEach(function(key) {
    return filteredProps[key] = originalProps[key];
  });
  return filteredProps;
};
var parseReactElement = function parseReactElement2(element, options) {
  var _options$displayName = options.displayName, displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;
  if (typeof element === "string") {
    return createStringTreeNode(element);
  } else if (typeof element === "number") {
    return createNumberTreeNode(element);
  } else if (!import_react.default.isValidElement(element)) {
    throw new Error("react-element-to-jsx-string: Expected a React.Element, got `".concat(_typeof(element), "`"));
  }
  var displayName = displayNameFn(element);
  var props = filterProps(element.props, noChildren);
  if (element.ref !== null) {
    props.ref = element.ref;
  }
  var key = element.key;
  if (typeof key === "string" && key.search(/^\./)) {
    props.key = key;
  }
  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);
  var childrens = import_react.default.Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function(child) {
    return parseReactElement2(child, options);
  });
  if (supportFragment && element.type === import_react.Fragment) {
    return createReactFragmentTreeNode(key, childrens);
  }
  return createReactElementTreeNode(displayName, props, defaultProps, childrens);
};
function noRefCheck() {
}
var inlineFunction = function inlineFunction2(fn) {
  return fn.toString().split("\n").map(function(line) {
    return line.trim();
  }).join("");
};
var defaultFunctionValue = inlineFunction;
var formatFunction = function(fn, options) {
  var _options$functionValu = options.functionValue, functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu, showFunctions = options.showFunctions;
  if (!showFunctions && functionValue === defaultFunctionValue) {
    return functionValue(noRefCheck);
  }
  return functionValue(fn);
};
var formatComplexDataStructure = function(value, inline, lvl, options) {
  var normalizedValue = sortObject(value);
  var stringifiedValue = (0, import_pretty_print_object.prettyPrint)(normalizedValue, {
    transform: function transform(currentObj, prop, originalResult) {
      var currentValue = currentObj[prop];
      if (currentValue && (0, import_react.isValidElement)(currentValue)) {
        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);
      }
      if (typeof currentValue === "function") {
        return formatFunction(currentValue, options);
      }
      return originalResult;
    }
  });
  if (inline) {
    return stringifiedValue.replace(/\s+/g, " ").replace(/{ /g, "{").replace(/ }/g, "}").replace(/\[ /g, "[").replace(/ ]/g, "]");
  }
  return stringifiedValue.replace(/\t/g, spacer(1, options.tabStop)).replace(/\n([^$])/g, "\n".concat(spacer(lvl + 1, options.tabStop), "$1"));
};
var escape$1 = function escape(s) {
  return s.replace(/"/g, "&quot;");
};
var formatPropValue = function formatPropValue2(propValue, inline, lvl, options) {
  if (typeof propValue === "number") {
    return "{".concat(String(propValue), "}");
  }
  if (typeof propValue === "string") {
    return '"'.concat(escape$1(propValue), '"');
  }
  if (_typeof(propValue) === "symbol") {
    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\((.*)\)/, "$1");
    if (!symbolDescription) {
      return "{Symbol()}";
    }
    return "{Symbol('".concat(symbolDescription, "')}");
  }
  if (typeof propValue === "function") {
    return "{".concat(formatFunction(propValue, options), "}");
  }
  if ((0, import_react.isValidElement)(propValue)) {
    return "{".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), "}");
  }
  if (propValue instanceof Date) {
    if (isNaN(propValue.valueOf())) {
      return "{new Date(NaN)}";
    }
    return '{new Date("'.concat(propValue.toISOString(), '")}');
  }
  if (isPlainObject(propValue) || Array.isArray(propValue)) {
    return "{".concat(formatComplexDataStructure(propValue, inline, lvl, options), "}");
  }
  return "{".concat(String(propValue), "}");
};
var formatProp = function(name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {
  if (!hasValue && !hasDefaultValue) {
    throw new Error('The prop "'.concat(name, '" has no value and no default: could not be formatted'));
  }
  var usedValue = hasValue ? value : defaultValue;
  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax, tabStop = options.tabStop;
  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);
  var attributeFormattedInline = " ";
  var attributeFormattedMultiline = "\n".concat(spacer(lvl + 1, tabStop));
  var isMultilineAttribute = formattedPropValue.includes("\n");
  if (useBooleanShorthandSyntax && formattedPropValue === "{false}" && !hasDefaultValue) {
    attributeFormattedInline = "";
    attributeFormattedMultiline = "";
  } else if (useBooleanShorthandSyntax && formattedPropValue === "{true}") {
    attributeFormattedInline += "".concat(name);
    attributeFormattedMultiline += "".concat(name);
  } else {
    attributeFormattedInline += "".concat(name, "=").concat(formattedPropValue);
    attributeFormattedMultiline += "".concat(name, "=").concat(formattedPropValue);
  }
  return {
    attributeFormattedInline,
    attributeFormattedMultiline,
    isMultilineAttribute
  };
};
var mergeSiblingPlainStringChildrenReducer = function(previousNodes, currentNode) {
  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);
  var previousNode = previousNodes[previousNodes.length - 1];
  if (previousNode && (currentNode.type === "string" || currentNode.type === "number") && (previousNode.type === "string" || previousNode.type === "number")) {
    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));
  } else {
    if (previousNode) {
      nodes.push(previousNode);
    }
    nodes.push(currentNode);
  }
  return nodes;
};
var isKeyOrRefProps = function isKeyOrRefProps2(propName) {
  return ["key", "ref"].includes(propName);
};
var sortPropsByNames = function(shouldSortUserProps) {
  return function(props) {
    var haveKeyProp = props.includes("key");
    var haveRefProp = props.includes("ref");
    var userPropsOnly = props.filter(function(oneProp) {
      return !isKeyOrRefProps(oneProp);
    });
    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) : _toConsumableArray(userPropsOnly);
    if (haveRefProp) {
      sortedProps.unshift("ref");
    }
    if (haveKeyProp) {
      sortedProps.unshift("key");
    }
    return sortedProps;
  };
};
function createPropFilter(props, filter) {
  if (Array.isArray(filter)) {
    return function(key) {
      return filter.indexOf(key) === -1;
    };
  } else {
    return function(key) {
      return filter(props[key], key);
    };
  }
}
var compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation2(element, formattedElement, inline, lvl, options) {
  var tabStop = options.tabStop;
  if (element.type === "string") {
    return formattedElement.split("\n").map(function(line, offset) {
      if (offset === 0) {
        return line;
      }
      return "".concat(spacer(lvl, tabStop)).concat(line);
    }).join("\n");
  }
  return formattedElement;
};
var formatOneChildren = function formatOneChildren2(inline, lvl, options) {
  return function(element) {
    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);
  };
};
var onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue2(defaultProps, props) {
  return function(propName) {
    var haveDefaultValue = Object.keys(defaultProps).includes(propName);
    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];
  };
};
var isInlineAttributeTooLong = function isInlineAttributeTooLong2(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {
  if (!maxInlineAttributesLineLength) {
    return attributes.length > 1;
  }
  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;
};
var shouldRenderMultilineAttr = function shouldRenderMultilineAttr2(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {
  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;
};
var formatReactElementNode = function(node, inline, lvl, options) {
  var type = node.type, _node$displayName = node.displayName, displayName = _node$displayName === void 0 ? "" : _node$displayName, childrens = node.childrens, _node$props = node.props, props = _node$props === void 0 ? {} : _node$props, _node$defaultProps = node.defaultProps, defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;
  if (type !== "ReactElement") {
    throw new Error('The "formatReactElementNode" function could only format node of type "ReactElement". Given:  '.concat(type));
  }
  var filterProps3 = options.filterProps, maxInlineAttributesLineLength = options.maxInlineAttributesLineLength, showDefaultProps = options.showDefaultProps, sortProps = options.sortProps, tabStop = options.tabStop;
  var out = "<".concat(displayName);
  var outInlineAttr = out;
  var outMultilineAttr = out;
  var containsMultilineAttr = false;
  var visibleAttributeNames = [];
  var propFilter = createPropFilter(props, filterProps3);
  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function(propName) {
    return visibleAttributeNames.push(propName);
  });
  Object.keys(defaultProps).filter(propFilter).filter(function() {
    return showDefaultProps;
  }).filter(function(defaultPropName) {
    return !visibleAttributeNames.includes(defaultPropName);
  }).forEach(function(defaultPropName) {
    return visibleAttributeNames.push(defaultPropName);
  });
  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);
  attributes.forEach(function(attributeName) {
    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options), attributeFormattedInline = _formatProp.attributeFormattedInline, attributeFormattedMultiline = _formatProp.attributeFormattedMultiline, isMultilineAttribute = _formatProp.isMultilineAttribute;
    if (isMultilineAttribute) {
      containsMultilineAttr = true;
    }
    outInlineAttr += attributeFormattedInline;
    outMultilineAttr += attributeFormattedMultiline;
  });
  outMultilineAttr += "\n".concat(spacer(lvl, tabStop));
  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {
    out = outMultilineAttr;
  } else {
    out = outInlineAttr;
  }
  if (childrens && childrens.length > 0) {
    var newLvl = lvl + 1;
    out += ">";
    if (!inline) {
      out += "\n";
      out += spacer(newLvl, tabStop);
    }
    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? "\n".concat(spacer(newLvl, tabStop)) : "");
    if (!inline) {
      out += "\n";
      out += spacer(newLvl - 1, tabStop);
    }
    out += "</".concat(displayName, ">");
  } else {
    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {
      out += " ";
    }
    out += "/>";
  }
  return out;
};
var REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = "";
var REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = "React.Fragment";
var toReactElementTreeNode = function toReactElementTreeNode2(displayName, key, childrens) {
  var props = {};
  if (key) {
    props = {
      key
    };
  }
  return {
    type: "ReactElement",
    displayName,
    props,
    defaultProps: {},
    childrens
  };
};
var isKeyedFragment = function isKeyedFragment2(_ref) {
  var key = _ref.key;
  return Boolean(key);
};
var hasNoChildren = function hasNoChildren2(_ref2) {
  var childrens = _ref2.childrens;
  return childrens.length === 0;
};
var formatReactFragmentNode = function(node, inline, lvl, options) {
  var type = node.type, key = node.key, childrens = node.childrens;
  if (type !== "ReactFragment") {
    throw new Error('The "formatReactFragmentNode" function could only format node of type "ReactFragment". Given: '.concat(type));
  }
  var useFragmentShortSyntax = options.useFragmentShortSyntax;
  var displayName;
  if (useFragmentShortSyntax) {
    if (hasNoChildren(node) || isKeyedFragment(node)) {
      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;
    } else {
      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;
    }
  } else {
    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;
  }
  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);
};
var jsxStopChars = ["<", ">", "{", "}"];
var shouldBeEscaped = function shouldBeEscaped2(s) {
  return jsxStopChars.some(function(jsxStopChar) {
    return s.includes(jsxStopChar);
  });
};
var escape2 = function escape3(s) {
  if (!shouldBeEscaped(s)) {
    return s;
  }
  return "{`".concat(s, "`}");
};
var preserveTrailingSpace = function preserveTrailingSpace2(s) {
  var result = s;
  if (result.endsWith(" ")) {
    result = result.replace(/^(.*?)(\s+)$/, "$1{'$2'}");
  }
  if (result.startsWith(" ")) {
    result = result.replace(/^(\s+)(.*)$/, "{'$1'}$2");
  }
  return result;
};
var formatTreeNode = function(node, inline, lvl, options) {
  if (node.type === "number") {
    return String(node.value);
  }
  if (node.type === "string") {
    return node.value ? "".concat(preserveTrailingSpace(escape2(String(node.value)))) : "";
  }
  if (node.type === "ReactElement") {
    return formatReactElementNode(node, inline, lvl, options);
  }
  if (node.type === "ReactFragment") {
    return formatReactFragmentNode(node, inline, lvl, options);
  }
  throw new TypeError('Unknow format type "'.concat(node.type, '"'));
};
var formatTree = function(node, options) {
  return formatTreeNode(node, false, 0, options);
};
var reactElementToJsxString = function reactElementToJsxString2(element) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$filterProps = _ref.filterProps, filterProps3 = _ref$filterProps === void 0 ? [] : _ref$filterProps, _ref$showDefaultProps = _ref.showDefaultProps, showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps, _ref$showFunctions = _ref.showFunctions, showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions, functionValue = _ref.functionValue, _ref$tabStop = _ref.tabStop, tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop, _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax, useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth, _ref$useFragmentShort = _ref.useFragmentShortSyntax, useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort, _ref$sortProps = _ref.sortProps, sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps, maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength, displayName = _ref.displayName;
  if (!element) {
    throw new Error("react-element-to-jsx-string: Expected a ReactElement");
  }
  var options = {
    filterProps: filterProps3,
    showDefaultProps,
    showFunctions,
    functionValue,
    tabStop,
    useBooleanShorthandSyntax,
    useFragmentShortSyntax,
    sortProps,
    maxInlineAttributesLineLength,
    displayName
  };
  return formatTree(parseReactElement(element, options), options);
};

// node_modules/@storybook/react/dist/config.mjs
var import_react2 = __toESM(require_react(), 1);
var import_preview_api = __toESM(require_preview_api(), 1);
var import_client_logger = __toESM(require_client_logger(), 1);
function generateFuncSignature(params, returns) {
  let hasParams = params != null, hasReturns = returns != null;
  if (!hasParams && !hasReturns)
    return "";
  let funcParts = [];
  if (hasParams) {
    let funcParams = params.map((x) => {
      let prettyName = x.getPrettyName(), typeName = x.getTypeName();
      return typeName != null ? `${prettyName}: ${typeName}` : prettyName;
    });
    funcParts.push(`(${funcParams.join(", ")})`);
  } else
    funcParts.push("()");
  return hasReturns && funcParts.push(`=> ${returns.getTypeName()}`), funcParts.join(" ");
}
function generateShortFuncSignature(params, returns) {
  let hasParams = params != null, hasReturns = returns != null;
  if (!hasParams && !hasReturns)
    return "";
  let funcParts = [];
  return hasParams ? funcParts.push("( ... )") : funcParts.push("()"), hasReturns && funcParts.push(`=> ${returns.getTypeName()}`), funcParts.join(" ");
}
function toMultilineSignature(signature) {
  return signature.replace(/,/g, `,\r
`);
}
var CUSTOM_CAPTION = "custom";
var OBJECT_CAPTION = "object";
var ARRAY_CAPTION = "array";
var CLASS_CAPTION = "class";
var FUNCTION_CAPTION = "func";
var ELEMENT_CAPTION = "element";
function isHtmlTag(tagName) {
  return import_html_tags.default.includes(tagName.toLowerCase());
}
var BASIC_OPTIONS = { format: { indent: { style: "  " }, semicolons: false } };
var COMPACT_OPTIONS = { ...BASIC_OPTIONS, format: { newline: "" } };
var PRETTY_OPTIONS = { ...BASIC_OPTIONS };
function generateCode(ast, compact = false) {
  return (0, import_escodegen.generate)(ast, compact ? COMPACT_OPTIONS : PRETTY_OPTIONS);
}
function generateObjectCode(ast, compact = false) {
  return compact ? generateCompactObjectCode(ast) : generateCode(ast);
}
function generateCompactObjectCode(ast) {
  let result = generateCode(ast, true);
  return result.endsWith(" }") || (result = `${result.slice(0, -1)} }`), result;
}
function generateArrayCode(ast, compact = false) {
  return compact ? generateCompactArrayCode(ast) : generateMultilineArrayCode(ast);
}
function generateMultilineArrayCode(ast) {
  let result = generateCode(ast);
  return result.endsWith("  }]") && (result = dedent(result)), result;
}
function generateCompactArrayCode(ast) {
  let result = generateCode(ast, true);
  return result.startsWith("[    ") && (result = result.replace("[    ", "[")), result;
}
var isMemo2 = (component) => component.$$typeof === Symbol.for("react.memo");
var isForwardRef2 = (component) => component.$$typeof === Symbol.for("react.forward_ref");
var ACORN_WALK_VISITORS = { ...base, JSXElement: () => {
} };
var acornParser = Parser.extend((0, import_acorn_jsx.default)());
function extractIdentifierName(identifierNode) {
  return identifierNode != null ? identifierNode.name : null;
}
function filterAncestors(ancestors) {
  return ancestors.filter((x) => x.type === "ObjectExpression" || x.type === "ArrayExpression");
}
function calculateNodeDepth(node) {
  let depths = [];
  return ancestor(node, { ObjectExpression(_, ancestors) {
    depths.push(filterAncestors(ancestors).length);
  }, ArrayExpression(_, ancestors) {
    depths.push(filterAncestors(ancestors).length);
  } }, ACORN_WALK_VISITORS), Math.max(...depths);
}
function parseIdentifier(identifierNode) {
  return { inferredType: { type: "Identifier", identifier: extractIdentifierName(identifierNode) }, ast: identifierNode };
}
function parseLiteral(literalNode) {
  return { inferredType: { type: "Literal" }, ast: literalNode };
}
function parseFunction(funcNode) {
  let innerJsxElementNode;
  simple(funcNode.body, { JSXElement(node) {
    innerJsxElementNode = node;
  } }, ACORN_WALK_VISITORS);
  let inferredType = { type: innerJsxElementNode != null ? "Element" : "Function", params: funcNode.params, hasParams: funcNode.params.length !== 0 }, identifierName = extractIdentifierName(funcNode.id);
  return identifierName != null && (inferredType.identifier = identifierName), { inferredType, ast: funcNode };
}
function parseClass(classNode) {
  let innerJsxElementNode;
  return simple(classNode.body, { JSXElement(node) {
    innerJsxElementNode = node;
  } }, ACORN_WALK_VISITORS), { inferredType: { type: innerJsxElementNode != null ? "Element" : "Class", identifier: extractIdentifierName(classNode.id) }, ast: classNode };
}
function parseJsxElement(jsxElementNode) {
  let inferredType = { type: "Element" }, identifierName = extractIdentifierName(jsxElementNode.openingElement.name);
  return identifierName != null && (inferredType.identifier = identifierName), { inferredType, ast: jsxElementNode };
}
function parseCall(callNode) {
  let identifierNode = callNode.callee.type === "MemberExpression" ? callNode.callee.property : callNode.callee;
  return extractIdentifierName(identifierNode) === "shape" ? parseObject(callNode.arguments[0]) : null;
}
function parseObject(objectNode) {
  return { inferredType: { type: "Object", depth: calculateNodeDepth(objectNode) }, ast: objectNode };
}
function parseArray(arrayNode) {
  return { inferredType: { type: "Array", depth: calculateNodeDepth(arrayNode) }, ast: arrayNode };
}
function parseExpression(expression) {
  switch (expression.type) {
    case "Identifier":
      return parseIdentifier(expression);
    case "Literal":
      return parseLiteral(expression);
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return parseFunction(expression);
    case "ClassExpression":
      return parseClass(expression);
    case "JSXElement":
      return parseJsxElement(expression);
    case "CallExpression":
      return parseCall(expression);
    case "ObjectExpression":
      return parseObject(expression);
    case "ArrayExpression":
      return parseArray(expression);
    default:
      return null;
  }
}
function parse(value) {
  let ast = acornParser.parse(`(${value})`), parsingResult = { inferredType: { type: "Unknown" }, ast };
  if (ast.body[0] != null) {
    let rootNode = ast.body[0];
    switch (rootNode.type) {
      case "ExpressionStatement": {
        let expressionResult = parseExpression(rootNode.expression);
        expressionResult != null && (parsingResult = expressionResult);
        break;
      }
    }
  }
  return parsingResult;
}
function inspectValue(value) {
  try {
    return { ...parse(value) };
  } catch {
  }
  return { inferredType: { type: "Unknown" } };
}
var MAX_FUNC_LENGTH = 150;
function createTypeDef({ name, short, compact, full, inferredType }) {
  return { name, short, compact, full: full ?? short, inferredType };
}
function cleanPropTypes(value) {
  return value.replace(/PropTypes./g, "").replace(/.isRequired/g, "");
}
function splitIntoLines(value) {
  return value.split(/\r?\n/);
}
function prettyObject(ast, compact = false) {
  return cleanPropTypes(generateObjectCode(ast, compact));
}
function prettyArray(ast, compact = false) {
  return cleanPropTypes(generateCode(ast, compact));
}
function getCaptionForInspectionType(type) {
  switch (type) {
    case "Object":
      return OBJECT_CAPTION;
    case "Array":
      return ARRAY_CAPTION;
    case "Class":
      return CLASS_CAPTION;
    case "Function":
      return FUNCTION_CAPTION;
    case "Element":
      return ELEMENT_CAPTION;
    default:
      return CUSTOM_CAPTION;
  }
}
function generateTypeFromString(value, originalTypeName) {
  let { inferredType, ast } = inspectValue(value), { type } = inferredType, short, compact, full;
  switch (type) {
    case "Identifier":
    case "Literal":
      short = value, compact = value;
      break;
    case "Object": {
      let { depth } = inferredType;
      short = OBJECT_CAPTION, compact = depth === 1 ? prettyObject(ast, true) : null, full = prettyObject(ast);
      break;
    }
    case "Element": {
      let { identifier } = inferredType;
      short = identifier != null && !isHtmlTag(identifier) ? identifier : ELEMENT_CAPTION, compact = splitIntoLines(value).length === 1 ? value : null, full = value;
      break;
    }
    case "Array": {
      let { depth } = inferredType;
      short = ARRAY_CAPTION, compact = depth <= 2 ? prettyArray(ast, true) : null, full = prettyArray(ast);
      break;
    }
    default:
      short = getCaptionForInspectionType(type), compact = splitIntoLines(value).length === 1 ? value : null, full = value;
      break;
  }
  return createTypeDef({ name: originalTypeName, short, compact, full, inferredType: type });
}
function generateCustom({ raw }) {
  return raw != null ? generateTypeFromString(raw, "custom") : createTypeDef({ name: "custom", short: CUSTOM_CAPTION, compact: CUSTOM_CAPTION });
}
function generateFunc(extractedProp) {
  let { jsDocTags } = extractedProp;
  return jsDocTags != null && (jsDocTags.params != null || jsDocTags.returns != null) ? createTypeDef({ name: "func", short: generateShortFuncSignature(jsDocTags.params, jsDocTags.returns), compact: null, full: generateFuncSignature(jsDocTags.params, jsDocTags.returns) }) : createTypeDef({ name: "func", short: FUNCTION_CAPTION, compact: FUNCTION_CAPTION });
}
function generateShape(type, extractedProp) {
  let fields = Object.keys(type.value).map((key) => `${key}: ${generateType(type.value[key], extractedProp).full}`).join(", "), { inferredType, ast } = inspectValue(`{ ${fields} }`), { depth } = inferredType;
  return createTypeDef({ name: "shape", short: OBJECT_CAPTION, compact: depth === 1 && ast ? prettyObject(ast, true) : null, full: ast ? prettyObject(ast) : null });
}
function objectOf(of) {
  return `objectOf(${of})`;
}
function generateObjectOf(type, extractedProp) {
  let { short, compact, full } = generateType(type.value, extractedProp);
  return createTypeDef({ name: "objectOf", short: objectOf(short), compact: compact != null ? objectOf(compact) : null, full: full && objectOf(full) });
}
function generateUnion(type, extractedProp) {
  if (Array.isArray(type.value)) {
    let values = type.value.reduce((acc, v) => {
      let { short, compact, full } = generateType(v, extractedProp);
      return acc.short.push(short), acc.compact.push(compact), acc.full.push(full), acc;
    }, { short: [], compact: [], full: [] });
    return createTypeDef({ name: "union", short: values.short.join(" | "), compact: values.compact.every((x) => x != null) ? values.compact.join(" | ") : null, full: values.full.join(" | ") });
  }
  return createTypeDef({ name: "union", short: type.value, compact: null });
}
function generateEnumValue({ value, computed }) {
  return computed ? generateTypeFromString(value, "enumvalue") : createTypeDef({ name: "enumvalue", short: value, compact: value });
}
function generateEnum(type) {
  if (Array.isArray(type.value)) {
    let values = type.value.reduce((acc, v) => {
      let { short, compact, full } = generateEnumValue(v);
      return acc.short.push(short), acc.compact.push(compact), acc.full.push(full), acc;
    }, { short: [], compact: [], full: [] });
    return createTypeDef({ name: "enum", short: values.short.join(" | "), compact: values.compact.every((x) => x != null) ? values.compact.join(" | ") : null, full: values.full.join(" | ") });
  }
  return createTypeDef({ name: "enum", short: type.value, compact: type.value });
}
function braceAfter(of) {
  return `${of}[]`;
}
function braceAround(of) {
  return `[${of}]`;
}
function createArrayOfObjectTypeDef(short, compact, full) {
  return createTypeDef({ name: "arrayOf", short: braceAfter(short), compact: compact != null ? braceAround(compact) : null, full: full && braceAround(full) });
}
function generateArray(type, extractedProp) {
  let { name, short, compact, full, inferredType } = generateType(type.value, extractedProp);
  if (name === "custom") {
    if (inferredType === "Object")
      return createArrayOfObjectTypeDef(short, compact, full);
  } else if (name === "shape")
    return createArrayOfObjectTypeDef(short, compact, full);
  return createTypeDef({ name: "arrayOf", short: braceAfter(short), compact: braceAfter(short) });
}
function generateType(type, extractedProp) {
  try {
    switch (type.name) {
      case "custom":
        return generateCustom(type);
      case "func":
        return generateFunc(extractedProp);
      case "shape":
        return generateShape(type, extractedProp);
      case "instanceOf":
        return createTypeDef({ name: "instanceOf", short: type.value, compact: type.value });
      case "objectOf":
        return generateObjectOf(type, extractedProp);
      case "union":
        return generateUnion(type, extractedProp);
      case "enum":
        return generateEnum(type);
      case "arrayOf":
        return generateArray(type, extractedProp);
      default:
        return createTypeDef({ name: type.name, short: type.name, compact: type.name });
    }
  } catch (e) {
    console.error(e);
  }
  return createTypeDef({ name: "unknown", short: "unknown", compact: "unknown" });
}
function createType(extractedProp) {
  let { type } = extractedProp.docgenInfo;
  if (type == null)
    return null;
  try {
    switch (type.name) {
      case "custom":
      case "shape":
      case "instanceOf":
      case "objectOf":
      case "union":
      case "enum":
      case "arrayOf": {
        let { short, compact, full } = generateType(type, extractedProp);
        return compact != null && !isTooLongForTypeSummary(compact) ? createSummaryValue(compact) : full ? createSummaryValue(short, full) : createSummaryValue(short);
      }
      case "func": {
        let { short, full } = generateType(type, extractedProp), summary = short, detail;
        return full && full.length < MAX_FUNC_LENGTH ? summary = full : full && (detail = toMultilineSignature(full)), createSummaryValue(summary, detail);
      }
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}
function generateObject({ inferredType, ast }) {
  let { depth } = inferredType;
  if (depth === 1) {
    let compactObject = generateObjectCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactObject))
      return createSummaryValue(compactObject);
  }
  return createSummaryValue(OBJECT_CAPTION, generateObjectCode(ast));
}
function generateArray2({ inferredType, ast }) {
  let { depth } = inferredType;
  if (depth <= 2) {
    let compactArray = generateArrayCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactArray))
      return createSummaryValue(compactArray);
  }
  return createSummaryValue(ARRAY_CAPTION, generateArrayCode(ast));
}
function getPrettyFuncIdentifier(identifier, hasArguments) {
  return hasArguments ? `${identifier}( ... )` : `${identifier}()`;
}
function getPrettyElementIdentifier(identifier) {
  return `<${identifier} />`;
}
function getPrettyIdentifier(inferredType) {
  let { type, identifier } = inferredType;
  switch (type) {
    case "Function":
      return getPrettyFuncIdentifier(identifier, inferredType.hasParams);
    case "Element":
      return getPrettyElementIdentifier(identifier);
    default:
      return identifier;
  }
}
function generateFunc2({ inferredType, ast }) {
  let { identifier } = inferredType;
  if (identifier != null)
    return createSummaryValue(getPrettyIdentifier(inferredType), generateCode(ast));
  let prettyCaption = generateCode(ast, true);
  return isTooLongForDefaultValueSummary(prettyCaption) ? createSummaryValue(FUNCTION_CAPTION, generateCode(ast)) : createSummaryValue(prettyCaption);
}
function generateElement(defaultValue, inspectionResult) {
  let { inferredType } = inspectionResult, { identifier } = inferredType;
  if (identifier != null && !isHtmlTag(identifier)) {
    let prettyIdentifier = getPrettyIdentifier(inferredType);
    return createSummaryValue(prettyIdentifier, defaultValue);
  }
  return isTooLongForDefaultValueSummary(defaultValue) ? createSummaryValue(ELEMENT_CAPTION, defaultValue) : createSummaryValue(defaultValue);
}
function createDefaultValue(defaultValue) {
  try {
    let inspectionResult = inspectValue(defaultValue);
    switch (inspectionResult.inferredType.type) {
      case "Object":
        return generateObject(inspectionResult);
      case "Function":
        return generateFunc2(inspectionResult);
      case "Element":
        return generateElement(defaultValue, inspectionResult);
      case "Array":
        return generateArray2(inspectionResult);
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}
function isReactElement(element) {
  return element.$$typeof != null;
}
function extractFunctionName(func, propName) {
  let { name } = func;
  return name !== "" && name !== "anonymous" && name !== propName ? name : null;
}
var stringResolver = (rawDefaultProp) => createSummaryValue(JSON.stringify(rawDefaultProp));
function generateReactObject(rawDefaultProp) {
  let { type } = rawDefaultProp, { displayName } = type, jsx2 = reactElementToJsxString(rawDefaultProp, {});
  if (displayName != null) {
    let prettyIdentifier = getPrettyElementIdentifier(displayName);
    return createSummaryValue(prettyIdentifier, jsx2);
  }
  if ((0, import_isString.default)(type) && isHtmlTag(type)) {
    let jsxSummary = reactElementToJsxString(rawDefaultProp, { tabStop: 0 }).replace(/\r?\n|\r/g, "");
    if (!isTooLongForDefaultValueSummary(jsxSummary))
      return createSummaryValue(jsxSummary);
  }
  return createSummaryValue(ELEMENT_CAPTION, jsx2);
}
var objectResolver = (rawDefaultProp) => {
  if (isReactElement(rawDefaultProp) && rawDefaultProp.type != null)
    return generateReactObject(rawDefaultProp);
  if ((0, import_isPlainObject.default)(rawDefaultProp)) {
    let inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateObject(inspectionResult);
  }
  if (Array.isArray(rawDefaultProp)) {
    let inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateArray2(inspectionResult);
  }
  return createSummaryValue(OBJECT_CAPTION);
};
var functionResolver = (rawDefaultProp, propDef) => {
  let isElement = false, inspectionResult;
  if ((0, import_isFunction.default)(rawDefaultProp.render))
    isElement = true;
  else if (rawDefaultProp.prototype != null && (0, import_isFunction.default)(rawDefaultProp.prototype.render))
    isElement = true;
  else {
    let innerElement;
    try {
      inspectionResult = inspectValue(rawDefaultProp.toString());
      let { hasParams, params } = inspectionResult.inferredType;
      hasParams ? params.length === 1 && params[0].type === "ObjectPattern" && (innerElement = rawDefaultProp({})) : innerElement = rawDefaultProp(), innerElement != null && isReactElement(innerElement) && (isElement = true);
    } catch {
    }
  }
  let funcName = extractFunctionName(rawDefaultProp, propDef.name);
  if (funcName != null) {
    if (isElement)
      return createSummaryValue(getPrettyElementIdentifier(funcName));
    inspectionResult != null && (inspectionResult = inspectValue(rawDefaultProp.toString()));
    let { hasParams } = inspectionResult.inferredType;
    return createSummaryValue(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var defaultResolver = (rawDefaultProp) => createSummaryValue(rawDefaultProp.toString());
var DEFAULT_TYPE_RESOLVERS = { string: stringResolver, object: objectResolver, function: functionResolver, default: defaultResolver };
function createTypeResolvers(customResolvers = {}) {
  return { ...DEFAULT_TYPE_RESOLVERS, ...customResolvers };
}
function createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef, typeResolvers = DEFAULT_TYPE_RESOLVERS) {
  try {
    switch (typeof rawDefaultProp) {
      case "string":
        return typeResolvers.string(rawDefaultProp, propDef);
      case "object":
        return typeResolvers.object(rawDefaultProp, propDef);
      case "function":
        return typeResolvers.function(rawDefaultProp, propDef);
      default:
        return typeResolvers.default(rawDefaultProp, propDef);
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}
function keepOriginalDefinitionOrder(extractedProps, component) {
  let { propTypes } = component;
  return propTypes != null ? Object.keys(propTypes).map((x) => extractedProps.find((y) => y.name === x)).filter(Boolean) : extractedProps;
}
var funcResolver = (rawDefaultProp, { name, type }) => {
  let isElement = type.summary === "element" || type.summary === "elementType", funcName = extractFunctionName(rawDefaultProp, name);
  if (funcName != null) {
    if (isElement)
      return createSummaryValue(getPrettyElementIdentifier(funcName));
    let { hasParams } = inspectValue(rawDefaultProp.toString()).inferredType;
    return createSummaryValue(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var rawDefaultPropTypeResolvers = createTypeResolvers({ function: funcResolver });
function enhancePropTypesProp(extractedProp, rawDefaultProp) {
  let { propDef } = extractedProp, newtype = createType(extractedProp);
  newtype != null && (propDef.type = newtype);
  let { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    let newDefaultValue = createDefaultValue(defaultValue.value);
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  } else if (rawDefaultProp != null) {
    let newDefaultValue = createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef, rawDefaultPropTypeResolvers);
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  }
  return propDef;
}
function enhancePropTypesProps(extractedProps, component) {
  let rawDefaultProps = component.defaultProps != null ? component.defaultProps : {}, enhancedProps = extractedProps.map((x) => enhancePropTypesProp(x, rawDefaultProps[x.propDef.name]));
  return keepOriginalDefinitionOrder(enhancedProps, component);
}
function enhanceTypeScriptProp(extractedProp, rawDefaultProp) {
  let { propDef } = extractedProp, { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    let newDefaultValue = createDefaultValue(defaultValue.value);
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  } else if (rawDefaultProp != null) {
    let newDefaultValue = createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef);
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  }
  return propDef;
}
function enhanceTypeScriptProps(extractedProps) {
  return extractedProps.map((prop) => enhanceTypeScriptProp(prop));
}
var propTypesMap = /* @__PURE__ */ new Map();
Object.keys(import_prop_types.default).forEach((typeName) => {
  let type = import_prop_types.default[typeName];
  propTypesMap.set(type, typeName), propTypesMap.set(type.isRequired, typeName);
});
function getPropDefs(component, section) {
  let processedComponent = component;
  !hasDocgen(component) && !component.propTypes && isMemo2(component) && (processedComponent = component.type);
  let extractedProps = extractComponentProps(processedComponent, section);
  if (extractedProps.length === 0)
    return [];
  switch (extractedProps[0].typeSystem) {
    case TypeSystem.JAVASCRIPT:
      return enhancePropTypesProps(extractedProps, component);
    case TypeSystem.TYPESCRIPT:
      return enhanceTypeScriptProps(extractedProps);
    default:
      return extractedProps.map((x) => x.propDef);
  }
}
var extractProps = (component) => ({ rows: getPropDefs(component, "props") });
var extractArgTypes = (component) => {
  if (component) {
    let { rows } = extractProps(component);
    if (rows)
      return rows.reduce((acc, row) => {
        let { name, description, type, sbType, defaultValue: defaultSummary, jsDocTags, required } = row;
        return acc[name] = { name, description, type: { required, ...sbType }, table: { type, jsDocTags, defaultValue: defaultSummary } }, acc;
      }, {});
  }
  return null;
};
function simplifyNodeForStringify(node) {
  if ((0, import_react2.isValidElement)(node)) {
    let props = Object.keys(node.props).reduce((acc, cur) => (acc[cur] = simplifyNodeForStringify(node.props[cur]), acc), {});
    return { ...node, props, _owner: null };
  }
  return Array.isArray(node) ? node.map(simplifyNodeForStringify) : node;
}
var renderJsx = (code, options) => {
  if (typeof code > "u")
    return import_client_logger.logger.warn("Too many skip or undefined component"), null;
  let renderedJSX = code, Type = renderedJSX.type;
  for (let i = 0; i < options.skip; i += 1) {
    if (typeof renderedJSX > "u")
      return import_client_logger.logger.warn("Cannot skip undefined element"), null;
    if (import_react2.default.Children.count(renderedJSX) > 1)
      return import_client_logger.logger.warn("Trying to skip an array of elements"), null;
    typeof renderedJSX.props.children > "u" ? (import_client_logger.logger.warn("Not enough children to skip elements."), typeof renderedJSX.type == "function" && renderedJSX.type.name === "" && (renderedJSX = import_react2.default.createElement(Type, { ...renderedJSX.props }))) : typeof renderedJSX.props.children == "function" ? renderedJSX = renderedJSX.props.children() : renderedJSX = renderedJSX.props.children;
  }
  let opts = { ...typeof options.displayName == "string" ? { showFunctions: true, displayName: () => options.displayName } : { displayName: (el) => el.type.displayName || (el.type === Symbol.for("react.profiler") ? "Profiler" : null) || getDocgenSection(el.type, "displayName") || (el.type.name !== "_default" ? el.type.name : null) || (typeof el.type == "function" ? "No Display Name" : null) || (isForwardRef2(el.type) ? el.type.render.name : null) || (isMemo2(el.type) ? el.type.type.name : null) || el.type }, ...{ filterProps: (value, key) => value !== void 0 }, ...options };
  return import_react2.default.Children.map(code, (c) => {
    let child = typeof c == "number" ? c.toString() : c, string = (typeof reactElementToJsxString == "function" ? reactElementToJsxString : reactElementToJsxString.default)(simplifyNodeForStringify(child), opts);
    if (string.indexOf("&quot;") > -1) {
      let matches = string.match(/\S+=\\"([^"]*)\\"/g);
      matches && matches.forEach((match) => {
        string = string.replace(match, match.replace(/&quot;/g, "'"));
      });
    }
    return string;
  }).join(`
`).replace(/function\s+noRefCheck\(\)\s+\{\}/g, "() => {}");
};
var defaultOpts = { skip: 0, showFunctions: false, enableBeautify: true, showDefaultProps: false };
var skipJsxRender = (context) => {
  var _a;
  let sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source, isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory;
  return (sourceParams == null ? void 0 : sourceParams.type) === SourceType.DYNAMIC ? false : !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === SourceType.CODE;
};
var isMdx = (node) => {
  var _a, _b;
  return ((_a = node.type) == null ? void 0 : _a.displayName) === "MDXCreateElement" && !!((_b = node.props) == null ? void 0 : _b.mdxType);
};
var mdxToJsx = (node) => {
  if (!isMdx(node))
    return node;
  let { mdxType, originalType, children, ...rest } = node.props, jsxChildren = [];
  return children && (jsxChildren = (Array.isArray(children) ? children : [children]).map(mdxToJsx)), (0, import_react2.createElement)(originalType, rest, ...jsxChildren);
};
var jsxDecorator = (storyFn, context) => {
  var _a, _b;
  let channel = import_preview_api.addons.getChannel(), skip = skipJsxRender(context), jsx2 = "";
  (0, import_preview_api.useEffect)(() => {
    if (!skip) {
      let { id, unmappedArgs } = context;
      channel.emit(SNIPPET_RENDERED, { id, source: jsx2, args: unmappedArgs });
    }
  });
  let story = storyFn();
  if (skip)
    return story;
  let options = { ...defaultOpts, ...(context == null ? void 0 : context.parameters.jsx) || {} }, storyJsx = ((_b = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source) == null ? void 0 : _b.excludeDecorators) ? context.originalStoryFn(context.args, context) : story, sourceJsx = mdxToJsx(storyJsx), rendered = renderJsx(sourceJsx, options);
  return rendered && (jsx2 = rendered), story;
};
var parameters = { docs: { story: { inline: true }, extractArgTypes, extractComponentDescription } };
var decorators = [jsxDecorator];
var argTypesEnhancers = [enhanceArgTypes];
var applyDecorators = (storyFn, decorators2) => {
  let jsxIndex = decorators2.findIndex((d) => d.originalFn === jsxDecorator), reorderedDecorators = jsxIndex === -1 ? decorators2 : [...decorators2.splice(jsxIndex, 1), ...decorators2];
  return (0, import_preview_api.defaultDecorateStory)(storyFn, reorderedDecorators);
};
var parameters2 = { renderer: "react", ...parameters };
export {
  applyDecorators,
  argTypesEnhancers,
  decorators,
  parameters2 as parameters,
  render,
  renderToCanvas
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@storybook_react_preview.js.map
